<!DOCTYPE html>
<html>
<head>
<title>LivingDocument.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="gptree-living-document"><strong>GPTree: Living Document</strong></h1>
<h2 id="1-team-info"><strong>1. Team info:</strong></h2>
<ul>
<li>Brittan Wadsworth: [ Frontend / Backend ]</li>
<li>Richman Pham: [ UI designer / Frontend  ]</li>
<li>Yana Martynyuk: [ UI designer / Frontend ]</li>
<li>Jungho Park: [ Backend ]</li>
<li>Jackson Tyler Lee Kent: [ Backend ]</li>
</ul>
<p>Github: <a href="https://github.com/Britwad/GPTree">https://github.com/Britwad/GPTree</a></p>
<p>We are using a Discord server as our primary communication tool. Members have agreed to operate with the following policy:</p>
<ul>
<li>Active hours are defined to be from 8am to 8pm Monday through Friday</li>
<li>A message in need of response can not be left unanswered for more than 6 active hours</li>
<li>A message using @ to refer to a team member by name must get a response from that member within 4 active hours</li>
<li>Team members will use each channel for its designated purpose, and will create a new channel if deemed helpful</li>
<li>Team members should still feel free to message and respond outside of active hours</li>
<li>Team members acknowledge that quick responses are extreamely helpful for the group cause, and will make efforts to respond sooner than later, especially for time-sensitive tasks.</li>
</ul>
<h2 id="2-product-description"><strong>2. Product description:</strong></h2>
<p><strong>Abstract</strong>:<br>
ChatGPT and other LLMs are incredible tools for conversational learning. They provide the user with the opportunity to pursue personal learning at their own pace on their own time. However, ChatGPT currently does not cover all the needs of those interested in personal learning. It is difficult to explore previous conversations, and users often only read the results of an LLM once. GPTree aims to solve these issues, and to create a cohesive framework for learning. Learning node by node, asking follow-up questions, users will effectively be generating their own personal textbooks. Under this framework, there are many additional features that can be incorporated. These include flashcard generations, tests of understanding, and utilization of space repetition learning principles to encourage long term understanding. This platform aims to be as broad as possible, without specific topics or courses, and will only restrict users when they are not requesting informative content.</p>
<p><strong>Goal:</strong><br>
Provide a cohesive framework that encourages and empowers user’s personal learning with long-lasting knowledge retention. This framework will make learning any topic feel less intimidating, and additionally will provide further support to ensure that the first time the user hears about a concept won’t be the last.</p>
<p><strong>Current Practice:</strong><br>
While there are an array of existing tools for education using AI, these tools are often scope limited, still exist essentially through a chat window, and typically are specialized towards schoolwork. Some examples include:</p>
<ul>
<li>ChatGPT Study mode, is a specialized chat window that emphasizes understanding rather than immediate answers</li>
<li>Oboe.fyi Generates a course upon user request that can be revisited, with potential follow up courses</li>
<li>YouLearn.ai Helps you understand your schoolwork by letting users upload textbooks or videos as reference points to be broken down and understood.</li>
<li>Learningro.com Uses AI to create personal learning experiences for students and to help teachers.</li>
</ul>
<p>For users who go to ChatGPT or other major LLMs to learn, they often get overwhelmed with the quantity of information that results. It can be easy to lose track of what ground has been covered, and there is little to no accountability for knowledge retention. These other platforms are often scope limited to just school, with a focus on personalized learning experiences.</p>
<p><strong>Novelty</strong>:<br>
The novelty of our approach comes from a tree-structure of learning. Each tree will represent a new exploration of a subject. Learning will be done node by node, where each node contains LLM generated information. Each node will give users the option for further learning either through flashcards, tests, or further questions. Further questions and clarifications will lead to the creation of a new node. As users explore a topic they will be able to see visible progress of what they have learned, and how it all connects. Furthermore, GPTree will have a place for users to go to practice concepts they have covered over all of their trees (topics). Here either flashcards or even more qualitative questions will be used to help users test their knowledge over wider gaps of time, ultimately cementing concepts in long term memory.</p>
<p><strong>Effects:</strong><br>
It is increasingly becoming the case that people resort to GPTs for day to day searching rather than an actual search engine. For those exploring the internet with the aim to learn more about a topic, we aim to be the place where that learning happens. We aim to ensure that GPTree always sports the latest model with the latest capabilities (including internet search and file reference). Our app will encourage actual and effective learning, of up to date information, rather than just immediate results that are quickly read and forgotten. Effectively, users will be generating a neatly structured textbook, making revisiting previous knowledge more convenient. Additionally with spaced repetition learning, users will be able to reinforce their knowledge of any topic they choose.</p>
<p><strong>Risks:</strong><br>
The most serious challenge or risk faced will be setting guardrails on LLM outputs to ensure consistently helpful outputs for any inputs the user may give. Relying on generated outputs for flexibility can lead to powerful products, but there is inevitable unpredictability that must be accounted for. LLM models are also not 100% correct all the time, the information collected and produced by the model cannot be guaranteed to be entirely factual. This potential inaccuracy may lead users to seek more reputable sources such as online textbooks and tutorials.<br>
To mitigate risks related to LLM output variability, we will do the following:</p>
<ul>
<li>Note to users that outputs are never guaranteed to be trustworthy, and that important information should be fact checked. This is the industry standard for LLM outputs (OpenAI has: “ChatGPT can make mistakes. Check important info.”)</li>
<li>Use a carefully engineered system prompt for the LLM that strictly requires all outputs to be educational, with pre-written responses for inputs that seem irrelevant or inappropriate to the task.</li>
<li>There is also the potential solution for LLM outputs to include an error message as part of a structured output, that then can be caught prior to generation to throw an error.</li>
</ul>
<p><strong>Major Features:</strong></p>
<ul>
<li>Dedicated web app with intuitive UI/UX that combines the following features.</li>
<li>Tree based navigation page will give organization to the user’s interaction with the chatBot.</li>
<li>Generation of potential follow-up questions with the option for users to ask their own. Each follow up question will lead to the creation of a new node with a new block of generated text answering the question.</li>
<li>Each node will be associated with a set of flash cards, and users will have the chance to review these flash cards to test their knowledge.</li>
<li>There will be a dedicated page for spaced repetition learning, where concepts from any tree the user has generated will be collected for the user to be tested on. The user will have control over which trees they want to be practicing.</li>
</ul>
<p><strong>Stretch Goals:</strong></p>
<ul>
<li>Complementary mobile app sharing similar UI. The main benefit of this app is that users will be able to practice their concepts and flash cards while on the go.</li>
<li>The option to generate tests either based on a single node or a tree. The users then can take this test, which may not be necessarily multiple choice questions, and it will be graded partially by the program and also by an LLM for short-answer questions.</li>
<li>Incorporating more multimodal features of LLMs such as vision, image generation, etc.</li>
<li>Implementing social features such as sharing or publishing trees for others to view.</li>
</ul>
<p><strong>Additional comments:</strong></p>
<ul>
<li>A new node is created off of an existing node whenever a follow up question is asked relative to a node. For example if a user had a node about eigenvectors, a new node could be created after asking “what is a determinant” inside the “eigenvector” node.</li>
<li>A single node finishes generation once the LLM is done responding (it usually finishes on its own, and for rare cases we can have a max-output length).</li>
</ul>
<h2 id="3-use-cases-functional-requirements"><strong>3. Use Cases (Functional Requirements):</strong></h2>
<h3 id="30-pages-and-visual-elements"><strong>3.0. Pages and Visual Elements</strong></h3>
<h4 id="pages">Pages</h4>
<ul>
<li><strong>View Tree</strong> - Here users will be presented with a visual tree of the generated nodes, they will have the option to click on nodes, or to create a new node off of an existing node by asking a follow-up question.
<ul>
<li><strong>View Node</strong> - Here users will see the generated text response from the LLM of the answer to their question. Each Node will consist of a Title, Question, Text, Key Points Summary, and Generated follow-up questions.</li>
<li><strong>View Flashcards</strong> Here users can view a set of <strong>flashcards</strong> either specific to the tree or specific to a single node.</li>
</ul>
</li>
<li><strong>Spaced Repetition Page</strong> - Here users will be presented a feed of <strong>Flash Cards</strong> based on the trees that they have generated. These <strong>Flash Cards</strong> will be presented using a spaced repetition scheduler, which will keep track of the user's success rate in remembering the information on the flash card.</li>
</ul>
<h4 id="visual-elements">Visual Elements</h4>
<ul>
<li><strong>Node</strong> - A clickable element that contains a single LLM generation of text relevant to the user's topic of interest. From any node users can ask &quot;follow-up questions&quot; that lead to the creation of a new, and connected, node whose generated text answers the follow up question. Users can generate a set of Flashcards based on the information contained in a node.</li>
<li><strong>Tree</strong> - A set of connected <strong>Nodes</strong>, with a root <strong>Node</strong>. The main functionality of <strong>Gptree</strong> is letting user's create, expand, and navigate these <strong>trees</strong>.</li>
<li><strong>Flash Card</strong> - A flash card represents a question / answer pair of text, which will be generated by an LLM to help users review and study information from <strong>Nodes</strong> or <strong>Trees</strong>.</li>
</ul>
<p><em>All following use cases will be between two actors: <strong>User</strong> and <strong>System</strong></em></p>
<h3 id="31-user-sign-in--sign-up"><strong>3.1. User Sign in / Sign up</strong></h3>
<p><strong>Triggers</strong></p>
<ul>
<li>User clicks &quot;Get Started&quot; button</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>User is on landing page</li>
<li>User is not signed in</li>
</ul>
<p><strong>Postconditions (success scenario)</strong></p>
<ul>
<li>User is signed into their account, using their google account, and can now create a tree. If they had not created an account before, a new user entity is associated with their email.</li>
</ul>
<p><strong>List of steps (success scenario)</strong></p>
<ol>
<li>System: Presents &quot;Continue with Google&quot; button that uses NextAuth.js</li>
<li>User: Clicks button</li>
<li>System: Prompts user to sign in with their google account, and asks for information/permissions</li>
<li>User: Enters information, gives permissions</li>
<li>System: NextAuth.js authenticates information, then passes user inf`ormation to server</li>
<li>System: A cookie is set so that frontend has access to which user is using site. Routes to landing page where user can create tree associated with their account.</li>
</ol>
<p><strong>Extensions/variations of the success scenario</strong></p>
<ul>
<li>The user wants to login using just their email, not necesarily google. They can &quot;Continue with email&quot;, then they will recieve an email with a one-time login url. They will have to repeat this process to sign in for future cases.</li>
<li>User previously used &quot;continue with google&quot; but this time they use &quot;continue with email&quot; with the same address. They will still be connected to the correct account, with a different OAuth method.</li>
</ul>
<p><strong>Exceptions: failure conditions and scenarios</strong></p>
<ul>
<li>The user provides an invalid email address. In this case we will display an error message for the user telling them to try again with valid input.</li>
</ul>
<h3 id="32-create-a-tree"><strong>3.2. Create a Tree</strong></h3>
<p><strong>Triggers</strong></p>
<ul>
<li>User clicks “New Tree” button</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>User has created an account on GPTree</li>
</ul>
<p><strong>Postconditions (success scenario)</strong></p>
<ul>
<li>There now exists a tree entity related to at least one node, where the node contains information relevant to the user's requested topic.</li>
</ul>
<p><strong>List of steps (success scenario)</strong></p>
<ol>
<li>System: Presents &quot;I want to learn about...&quot; text field</li>
<li>User:  Enters &quot;matrices&quot; in text field</li>
<li>System: A modal appears where text is generated to explain the requested topic</li>
<li>User: Scrolls to read content. Then clicks peripheral of modal to exit.</li>
<li>System: Display the generated node in an open space. The node focuses on mouse hover and can be clicked. The node has a button for asking a follow up question. There is a side panel that will list each created tree by the user, as well as a button to create a new tree.</li>
</ol>
<p><strong>Extensions/variations of the success scenario</strong></p>
<ul>
<li>The user wants to ask their own follow up question regarding the initial node, and types “how many eigenvectors does a matrix have?”. A new node branches off the original node and they can see the new text as it generates.</li>
</ul>
<p><strong>Exceptions: failure conditions and scenarios</strong></p>
<ul>
<li>LLM Generation Timeout or Failure. In this case we will throw an error message, reset the state, and ask the user to try again.</li>
<li>Connection Lost During Generation. In this case we will throw an error message, reset the state, and ask the user to try again.</li>
</ul>
<h3 id="33-generate-a-follow-up-node"><strong>3.3. Generate a follow-up Node</strong></h3>
<p><strong>Triggers</strong></p>
<ul>
<li>User clicks button on an existing node for follow-up questions</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>User has created an account on GPTree</li>
<li>User has created a Tree with at least one Node</li>
</ul>
<p><strong>Postconditions (success scenario)</strong></p>
<ul>
<li>There is now an additional Node on the tree, the node contains information answering the user's question, and it maintains the context of the nodes between it and the root. There are generated potential follow-up questions.</li>
</ul>
<p><strong>List of steps (success scenario)</strong></p>
<ol>
<li>System: A list of 3 potential follow-up questions appear next to the node, as well as an empty text box where user can enter their own question.</li>
<li>User: Clicks the first option (E.g. &quot;What is a determinant&quot;?)</li>
<li>System: A new node branches off the current node, and a modal appears displaying the question, generated text from LLM, and additional potential follow-up questions.</li>
</ol>
<p><strong>Extensions/variations of the success scenario</strong></p>
<ul>
<li>The user wants to ask their own follow up question regarding the initial node, and types “how many eigenvectors does a matrix have?”. A new node branches off the original node and they can see the new text as it generates.</li>
<li>The user also can click a follow-up question or write their own while in the Node modal. In this case, the modal switches to a new one and the user can see the generated text. When they exit the modal they can see the new Node connected to the previous one.</li>
</ul>
<p><strong>Exceptions: failure conditions and scenarios</strong></p>
<ul>
<li>LLM Generation Timeout or Failure. In this case we will throw an error message, reset the state, and ask the user to try again.</li>
<li>Connection Lost During Generation. In this case we will throw an error message, reset the state, and ask the user to try again.</li>
</ul>
<h3 id="34-view-an-existing-tree"><strong>3.4.  View an existing Tree</strong></h3>
<p><strong>Trigger</strong></p>
<ul>
<li>User clicks on a tree that was previously made</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>The user has made at least one tree</li>
<li>LLM and database accessible</li>
</ul>
<p><strong>Postconditions (Success)</strong></p>
<ul>
<li>The tree retains any new nodes added (if any) during review</li>
</ul>
<p><strong>List of Steps (Success Scenario)</strong></p>
<ol>
<li>User selects a tree to review</li>
<li>The data from the tree is fetched from the database</li>
<li>The tree is displayed correctly</li>
<li>The user asks any new questions they have</li>
<li>Nodes are added if needed</li>
<li>The user exits and returns to the menu</li>
</ol>
<p><strong>Extensions / Variations</strong></p>
<ul>
<li>“Quick Review” button that will select a flashcard from each node and give them as a list to the user</li>
<li>“Review Mode” button that will reduce nodes to brief summaries of the content they contain</li>
</ul>
<p><strong>Exceptions (Failure Conditions &amp; Scenarios)</strong></p>
<ul>
<li>The tree was improperly saved or the data was corrupted</li>
<li>“Review Mode” inaccurately summarizes the content of a node -&gt; display “Manual review recommended” near nodes with a lot of content</li>
</ul>
<h3 id="35-view-an-existing-node"><strong>3.5. View an existing node</strong></h3>
<p><strong>Triggers</strong></p>
<ul>
<li>User clicks a Node on the Tree view</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>User has created an account on GPTree</li>
<li>User has created a Tree with at least one Node</li>
<li>Target Node exists and the database is accessible</li>
</ul>
<p><strong>Postconditions (success scenario)</strong></p>
<ul>
<li>The Node is displayed with Title, Question, Text, Key Points Summary, and generated follow-up questions</li>
<li>Context is preserved with navigation to parent and child Nodes</li>
<li>Quick actions are available to ask a follow-up, generate flashcards, copy link, and mark for review</li>
<li>Reading progress is recorded for the user</li>
</ul>
<p><strong>List of steps (success scenario)</strong></p>
<ol>
<li>System: Receives request to open Node by id</li>
<li>System: Fetches Node content and related metadata, including parent and children</li>
<li>System: Renders Node view with Title, Question, Text, Key Points Summary, and suggested follow-ups</li>
<li>User: Reads content and optionally clicks a suggested follow-up or enters their own question</li>
<li>System: Provides navigation to parent and child Nodes and shows quick actions for flashcards and copying a shareable link</li>
</ol>
<p><strong>Extensions/variations of the success scenario</strong></p>
<ul>
<li>Open via pop up instead of full page to keep Tree visible</li>
<li>Keyboard shortcuts for next and previous Node navigation</li>
<li>Print or export the Node as a PDF or markdown</li>
<li>Show version history of the Node’s generated content</li>
<li>Inline search within the Node to highlight keywords</li>
</ul>
<p><strong>Exceptions: failure conditions and scenarios</strong></p>
<ul>
<li>Node not found or user lacks permission → Display “Node unavailable” and offer navigation back to the Tree</li>
<li>Database or network error → Show error message and a Retry option</li>
<li>Corrupted or incomplete content → Show “Content could not be loaded” with a prompt to regenerate or contact support</li>
</ul>
<h3 id="36-generate-flashcards-from-a-node"><strong>3.6. Generate Flashcards from a Node</strong></h3>
<p><strong>Trigger</strong></p>
<ul>
<li>Learner clicks “Generate Flashcards” on a node or while viewing Node</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>Target node exists with sufficient content.</li>
<li>LLM and database accessible.</li>
</ul>
<p><strong>Postconditions (Success)</strong></p>
<ul>
<li>A deck is created/updated with cards (Q&amp;A, fill-in-the-blanks, pictures, etc.).</li>
<li>Cards are inserted into the SRS queue with initial intervals.</li>
<li>Practice results update each card’s ease factor and next due date; mastery metrics updated.</li>
</ul>
<p><strong>List of Steps (Success Scenario)</strong></p>
<ol>
<li>Learner selects Generate Flashcards.</li>
<li>System prompts LLM to produce candidate cards following style and difficulty constraints.</li>
<li>Learner optionally edits/removes cards; confirms deck creation.</li>
<li>System persists cards and schedules initial reviews.</li>
<li>Learner opens Practice; cards are presented in due order.</li>
<li>Learner rates recall (Again/Hard/Good/Easy). (This tells how soon to show the card again and tweak the difficulty score.)</li>
<li>The app schedules the next review: farther away if it was easy, sooner if it was hard, and updates your progress.</li>
</ol>
<p><strong>Extensions / Variations</strong></p>
<ul>
<li>Whole branch at once: make cards for a subtree (several pages).</li>
<li>Export: send cards to CSV(Comma-Separated Values) /Anki (Flashcard app)</li>
<li>Auto‑adjust difficulty: if cards are too easy/hard, the app rewrites them to your level.</li>
</ul>
<p><strong>Exceptions (Failure Conditions &amp; Scenarios)</strong></p>
<ul>
<li>Too many or too long cards → The app keeps a limit and shortens long ones.</li>
<li>Time/clock issues → The server sets the right time so reviews aren’t duplicated or skipped.</li>
<li>Can’t save → Your draft list stays on your device, and you’ll see a Try again message.</li>
</ul>
<h3 id="37-generate-flashcards-from-a-tree"><strong>3.7. Generate Flashcards from a Tree</strong></h3>
<p><strong>Trigger</strong></p>
<ul>
<li>Learner clicks “Generate Flashcards” while viewing Tree</li>
</ul>
<p><strong>Preconditions</strong></p>
<ul>
<li>Target node exists with sufficient content.</li>
<li>LLM and database accessible.</li>
</ul>
<p><strong>Postconditions (Success)</strong></p>
<ul>
<li>A deck is created/updated with cards (Q&amp;A, fill-in-the-blanks, pictures, etc.).</li>
<li>Cards are inserted into the SRS queue with initial intervals.</li>
<li>Practice results update each card’s ease factor and next due date; mastery metrics updated.</li>
</ul>
<p><strong>List of Steps (Success Scenario)</strong></p>
<ol>
<li>Learner selects Generate Flashcards.</li>
<li>System prompts LLM to produce candidate cards following style and difficulty constraints.</li>
<li>Learner optionally edits/removes cards; confirms deck creation.</li>
<li>System persists cards and schedules initial reviews.</li>
<li>Learner opens Practice; cards are presented in due order.</li>
<li>Learner rates recall (Again/Hard/Good/Easy). (This tells how soon to show the card again and tweak the difficulty score.)</li>
<li>The app schedules the next review: farther away if it was easy, sooner if it was hard, and updates your progress.</li>
</ol>
<p><strong>Extensions / Variations</strong></p>
<ul>
<li>Whole branch at once: make cards for a subtree (several pages).</li>
<li>Export: send cards to CSV(Comma-Separated Values) /Anki (Flashcard app)</li>
<li>Auto‑adjust difficulty: if cards are too easy/hard, the app rewrites them to your level.</li>
</ul>
<p><strong>Exceptions (Failure Conditions &amp; Scenarios)</strong></p>
<ul>
<li>Too many or too long cards → The app keeps a limit and shortens long ones.</li>
<li>Time/clock issues → The server sets the right time so reviews aren’t duplicated or skipped.</li>
<li>Can’t save → Your draft list stays on your device, and you’ll see a Try again message.</li>
</ul>
<h3 id="38-use-spaced-repetition-feed"><strong>3.8.  Use Spaced Repetition Feed</strong></h3>
<p><strong>Triggers</strong></p>
<p>The user goes back, looking at all the trees</p>
<p>Reminders given by the website about going back to previous topics</p>
<p><strong>Preconditions</strong></p>
<p>The user has at least one tree and a set of flashcards created for the corresponding tree</p>
<p>The website has saved the user's progress and the tree structure/topics</p>
<p><strong>Postconditions (success scenario)</strong></p>
<p>The user goes back to the previous topic tree</p>
<p>The user reviews the flashcards from that tree, recalling information previously given by the LLM</p>
<p>The app updates the progress of review</p>
<p><strong>List of steps (success scenario)</strong></p>
<ol>
<li>User selects Flashcards button</li>
<li>The website loads a new screen where user's previous conversations and current progress in review</li>
<li>User selects “Review previous topics”</li>
<li>The website shows the tree of previously studied topics</li>
<li>The User choses which topic to review</li>
<li>The website displays the flashcards from that topic</li>
<li>User flips through each flashcard to review them</li>
<li>The website marks which cards have been reviewed by the user</li>
<li>User ends review session by clicking end</li>
<li>Website brings user back to homepage</li>
</ol>
<p><strong>Extensions/variations of the success scenario</strong></p>
<p>The user notes specific “nodes” for later review</p>
<p>User filters flashcards, least reviewed, or those marked by the user</p>
<p><strong>Exceptions: failure conditions and scenarios</strong></p>
<p>Website fails to load tree data</p>
<p>Flashcards show the wrong information</p>
<h2 id="4-non-functional-requirements"><strong>4. Non-functional Requirements:</strong></h2>
<ul>
<li><strong>User information is secure:</strong> Any information that the users give us must be kept safe. Passwords and email addresses could be anything from ‘throwaway’ values that the user keeps separate from their important details, or they could match the values used to access their bank account, which means that we have to ensure that nobody can access their data. Even if no personal data is stored during the use of GPTree, we always have to be careful with whatever the user gives us.</li>
<li><strong>Scalable for more users with growth:</strong> For whatever systems we design, we need to ensure that they could be modified to handle a higher amount of traffic as more users interact with GPTree. Regardless of how many users we have, we still need to be able to maintain their personal trees, flashcards, quizzes, etc., so it’s important that we avoid designing around the idea of just serving a few users.</li>
<li><strong>As LLM models advance, making sure that model choice is modular and easy to change / update:</strong> As improvements are made in the technology available to us, it’s important that we design with the future in mind so that GPTree can improve the quality of its generated content and its ability to help users learn.</li>
</ul>
<h2 id="5-external-requirements"><strong>5. External Requirements:</strong></h2>
<ul>
<li>To handle invalid user input, irrelevant or inappropriate inputs from the user will be flagged by an LLM and will prompt users to try again..</li>
<li>We will be hosting this webapp on Vercel, which provides free public URL hosting.</li>
<li>To ensure that someone else can set up a new server, we will document the build process on the git repository readme. We plan to include a single script that will build the entire project.</li>
<li>Based on the amount of work required to complete the project, we feel that 5 people will be able to develop this over the course of the quarter. If it turns out that the project takes too much work, then we can scale down the complexity of the features to be more realistic. If it turns out that we have ample time, we plan on developing a mobile IOS app to complement the web page.</li>
</ul>
<h2 id="6-team-process-description"><strong>6. Team process description:</strong></h2>
<h3 id="technical-details">Technical Details</h3>
<p><strong>Frontend:</strong>
The website will be built using Next.js and the React library for a responsive and modular UI. Development will use TypeScript and SCSS for consistent styling and type safety. The app will be hosted on Vercel, allowing quick iteration and automatic deployment from GitHub.</p>
<p><strong>Backend:</strong>
The server side will be developed using Node.js and Next.js API routes. REST endpoints will support creation and retrieval of Trees, Nodes, Flashcards, and Quizzes.</p>
<p><strong>LLM Integration:</strong>
GPTree will use the Groq API during development for low-cost access to open-weight models such as gpt-oss-120b. Custom prompt engineering will ensure structured and educational responses. The system will remain modular to allow switching to other LLM providers as needed.</p>
<p><strong>Data Storage:</strong>
Our database will be hosted as a PostgreSQL database on Prisma. Prisma ORM will manage schemas, relationships, and migrations, ensuring type-safe access and scalable performance.</p>
<p><strong>Development Environment:</strong>
Development will take place in Visual Studio Code, using GitHub for version control and NPM for package management.</p>
<h3 id="team-structure">Team Structure</h3>
<p><strong>Brittan: Frontend/Backend</strong>. This team member has experience in the full stack development using <a href="http://Next.js">Next.js</a> and PostgreSQL. Since GPTree was their idea, they will be helping out on developing and connecting the front and backend, and ensuring general cohesion over the whole project.</p>
<p><strong>Jungho: Backend</strong>, we need this role to work with AI models and make sure data can be stored nicely into nodes, maintaining correct history per node (a node should contain the context of previous nodes). Is a good fit for the role having worked with OpenAI APIs and is interested in doing more.</p>
<p><strong>Richman: Frontend and UI/UX</strong>, this is needed for the app to feel approachable and consistent across the different components such as flashcards, quizzes, the trees, etc. Interested in doing frontend and UI, done design in the past for other projects in different classes.</p>
<p><strong>Yana: Frontend and UI/UX</strong>. This is important in order to create an attractive website for users and easy to navigate. It is also important for the website to feel satisfying to use and for people to continue to come back to the website.</p>
<p><strong>Jackson: Backend</strong>. This role is necessary to work with user data and the database of trees/related content, as well as the LLM’s that will generate the content that users see. He is a good fit for the role primarily because he is highly interested in learning about developing a backend.</p>
<table>
<thead>
<tr>
<th><strong>Week</strong></th>
<th><strong>Milestone</strong></th>
<th><strong>Task</strong></th>
<th><strong>Dependencies</strong></th>
<th><strong>Team / Role</strong></th>
<th style="text-align:right"><strong>Effort (person-weeks)</strong></th>
<th><strong>Success Criteria</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Week 3</strong></td>
<td><strong>Requirements &amp; Setup</strong></td>
<td>Define functional and non-functional requirements</td>
<td>None</td>
<td>All</td>
<td style="text-align:right">1.0</td>
<td>Requirements doc in repo and approved</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Define team policies and set up tools (Discord, GitHub)</td>
<td>None</td>
<td>All</td>
<td style="text-align:right">0.5</td>
<td>Policies in repo; channels and repo active</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Establish environments and hosting (Vercel, PostgreSQL)</td>
<td>Policies &amp; tools set up</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Web server reachable; DB connection verified</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Plan key pages and user journeys (Landing, Tree, Node, Flashcard, SR)</td>
<td>Requirements defined</td>
<td>UI/UX</td>
<td style="text-align:right">0.8</td>
<td>User-flow map approved</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Create low-fidelity wireframes for core pages</td>
<td>Page plan complete</td>
<td>UI/UX</td>
<td style="text-align:right">1.0</td>
<td>Wireframes for Landing/Tree/Node/Flashcard/SR</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> GPTree functional and non-functional requirements are solidified. Team processes are documented. <em>UI/UX:</em> Planning what features are needed and what each part of the website should do and look like. <em>Frontend:</em> Set up structure and basic pages, simple navigation. <em>Backend:</em> Get webserver and database online.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 4</strong></td>
<td><strong>Architecture Definition</strong></td>
<td>Define overall system architecture (frontend–API–LLM–DB)</td>
<td>Requirements defined</td>
<td>All</td>
<td style="text-align:right">1.0</td>
<td>Architecture doc approved</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Define Prisma schema (User, Tree, Node, Flashcard)</td>
<td>System architecture defined</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Schema migrated; seed runs</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Define REST API architecture (REST + LLM endpoints)</td>
<td>Prisma schema defined</td>
<td>Backend</td>
<td style="text-align:right">0.8</td>
<td>Endpoint spec in repo</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Component hierarchy diagram and folder layout</td>
<td>Wireframes complete</td>
<td>Frontend</td>
<td style="text-align:right">0.5</td>
<td>Component map in repo</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> System architecture is defined, including data flow, LLM integration, database schema, and API structure. Key UI/UX elements such as Trees, Nodes, Edges, and Flash Cards have prototype designs. <em>UI/UX:</em> Begin whiteboard process for landing page, tree page, SR learning page, create rough designs/wireframe. <em>Frontend:</em> Define component hierarchy and page layouts. <em>Backend:</em> Define Prisma Schema for key entities.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 5</strong></td>
<td><strong>Design Implementation</strong></td>
<td>Implement authentication (Google + email with NextAuth)</td>
<td>Prisma schema defined; API surface defined</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Sign-in/out works; session cookie set</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Build generic UI kit + SCSS structure (buttons, modals, inputs)</td>
<td>Component hierarchy diagram</td>
<td>Frontend</td>
<td style="text-align:right">1.0</td>
<td>Reusable components published</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Design high-fidelity UI for Landing/Tree/Node</td>
<td>Wireframes complete</td>
<td>UI/UX</td>
<td style="text-align:right">1.0</td>
<td>Approved design spec</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Static pages scaffold (Landing, Tree, Node)</td>
<td>UI kit ready; hi-fi design ready</td>
<td>Frontend</td>
<td style="text-align:right">1.0</td>
<td>Pages render; basic navigation works</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Implement REST endpoints (Trees, Nodes, Flashcards)</td>
<td>API surface defined; DB live</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>REST endpoints pass tests</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> Detailed definition of all software components has been completed, including packages, classes, and units of abstraction. Users can now sign in. <em>UI/UX:</em> Design for key components have been completed and are able to be implemented as React components styled with .scss. <em>Frontend:</em> Skeleton model of the tree and nodes designed, user sign on page and landing page functional. <em>Backend:</em> All REST endpoints defined for basic entities, routes for User sign on created using nextJS OAuth.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 6</strong></td>
<td><strong>Integration &amp; Use Cases</strong></td>
<td>Connect frontend to REST endpoints</td>
<td>REST endpoints implemented; static pages scaffolded</td>
<td>Frontend + Backend</td>
<td style="text-align:right">1.0</td>
<td>Fetch/create/update flows working</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Integrate Groq for node generation (server)</td>
<td>API surface defined; DB live</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Structured JSON output with context</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.1: User sign in / sign up (UI + flow)</td>
<td>Authentication implemented; hi-fi design ready</td>
<td>Frontend + UI/UX</td>
<td style="text-align:right">0.6</td>
<td>“Continue with Google/Email” completes</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.2: Create a Tree (UI + API + LLM)</td>
<td>Groq integrated; frontend–REST connected; designed Tree/Node UI</td>
<td>Frontend + Backend + UI/UX</td>
<td style="text-align:right">1.0</td>
<td>Root node generated and persisted</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.3: Generate Follow-up Node</td>
<td>UC 3.2 complete; Groq integrated; designed Node UI</td>
<td>Frontend + Backend + UI/UX</td>
<td style="text-align:right">1.0</td>
<td>Child node created with preserved context</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.4: View an existing Tree</td>
<td>Frontend–REST connected; designed Tree UI</td>
<td>Frontend + UI/UX</td>
<td style="text-align:right">0.6</td>
<td>Tree fetched and rendered; nav ok</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.5: View an existing Node</td>
<td>UC 3.4 complete; designed Node UI</td>
<td>Frontend + UI/UX</td>
<td style="text-align:right">0.5</td>
<td>Node detail modal/page shows content</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Global loading/error states + optimistic UX</td>
<td>Frontend–REST connected</td>
<td>Frontend</td>
<td style="text-align:right">0.5</td>
<td>Graceful errors; spinners; retries</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Initial hallway usability test pass</td>
<td>UC 3.1–3.5 complete</td>
<td>UI/UX</td>
<td style="text-align:right">0.5</td>
<td>Findings logged; priorities set</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> Users can now create Trees and generate Nodes. User testing begins. <em>UI/UX:</em> Design patterns created, UX tests documented. <em>Frontend:</em> Tree and Nodes now support LLM generation using backend. <em>Backend:</em> Routes written connecting to Groq for tree and follow-up node creation maintaining context.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 7</strong></td>
<td><strong>Flashcards &amp; Spaced Repetition</strong></td>
<td>Flashcard generation routes (node, tree)</td>
<td>REST endpoints implemented; Groq integrated</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Persisted cards with references</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.6: Generate Flashcards from a Node (UI)</td>
<td>Flashcard routes ready; designed Flashcard UI</td>
<td>Frontend + UI/UX</td>
<td style="text-align:right">0.8</td>
<td>Cards visible/editable; saved</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.7: Generate Flashcards from a Tree (UI)</td>
<td>Node flashcards UI complete; flashcard routes ready</td>
<td>Frontend + UI/UX</td>
<td style="text-align:right">0.8</td>
<td>Batch generation succeeds</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Design SR page high-fidelity spec</td>
<td>Wireframes complete</td>
<td>UI/UX</td>
<td style="text-align:right">0.5</td>
<td>Approved SR design</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Spaced Repetition scheduling logic (EF/intervals)</td>
<td>Flashcards persisted</td>
<td>Backend</td>
<td style="text-align:right">1.0</td>
<td>Next-due dates computed and updated</td>
</tr>
<tr>
<td></td>
<td></td>
<td>UC 3.8: Spaced Repetition Feed (UI + API)</td>
<td>SR logic ready; SR design ready</td>
<td>Frontend + UI/UX + Backend</td>
<td style="text-align:right">1.0</td>
<td>Due queue renders and advances</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> Support for Flash Cards is added, and Spaced Repetition Page in progress. <em>UI/UX:</em> Flashcard and SR design finalized, UX Testing begins. <em>Frontend:</em> Flashcard generation and viewing functional. <em>Backend:</em> Routes for Flashcards added for nodes and trees, DB supports SR.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 8</strong></td>
<td><strong>Beta Completion</strong></td>
<td>App-wide polish: loading/errors/progress indicators</td>
<td>UC 3.6–3.8 complete</td>
<td>Frontend</td>
<td style="text-align:right">0.5</td>
<td>Stable interactions across flows</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Whole-app UX validation and revisions</td>
<td>App-wide polish in place</td>
<td>UI/UX</td>
<td style="text-align:right">1.0</td>
<td>Confusing areas resolved</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Deploy Beta to Vercel preview</td>
<td>All core use cases complete</td>
<td>Backend</td>
<td style="text-align:right">0.3</td>
<td>Public preview URL shared</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> Spaced Repetition Page functional; all functional requirements in beta. <em>UI/UX:</em> Validate design with UX testing, revise confusing areas, test app as a whole. <em>Frontend:</em> Display node content with loading/error states. <em>Backend:</em> Generate follow up nodes to predict future questions.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 9</strong></td>
<td><strong>Peer Review &amp; Optimization</strong></td>
<td>Peer review and triage</td>
<td>Beta deployed</td>
<td>All</td>
<td style="text-align:right">1.0</td>
<td>Issues tracked and assigned</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Frontend performance + accessibility pass</td>
<td>Peer review complete</td>
<td>Frontend</td>
<td style="text-align:right">0.8</td>
<td>No major perf/ARIA issues</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Backend load/error/security tests</td>
<td>Peer review complete</td>
<td>Backend</td>
<td style="text-align:right">0.8</td>
<td>No REST/LLM errors under normal load</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> All functional requirements peer-reviewed; feedback documented and addressed. <em>UI/UX:</em> Thorough UX testing. <em>Frontend:</em> Final polish and bug fixes. <em>Backend:</em> No unexpected REST errors.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 10</strong></td>
<td><strong>Final Release &amp; Documentation</strong></td>
<td>Full end-to-end QA of use cases</td>
<td>Peer fixes complete</td>
<td>All</td>
<td style="text-align:right">1.0</td>
<td>All UC 3.1–3.8 verified</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Production deployment to Vercel</td>
<td>QA complete</td>
<td>Backend</td>
<td style="text-align:right">0.3</td>
<td>Stable production URL live</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Final docs and presentation</td>
<td>Production live</td>
<td>All</td>
<td style="text-align:right">1.0</td>
<td>Report and slides in repo</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> All functional requirements implemented and tested. Production version released with public URL. <em>UI/UX:</em> UX thoroughly tested by developers and users. <em>Frontend:</em> Final polish and QoL improvements. <em>Backend:</em> Production release on Vercel.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
<tr>
<td><strong>Week 11</strong></td>
<td><strong>Retrospective</strong></td>
<td>Individual + team retrospectives</td>
<td>Final release complete</td>
<td>All</td>
<td style="text-align:right">0.5</td>
<td>Retros posted; action items captured</td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>Timeline Detail:</strong> Product released and ready for presentation. Individual retrospective complete.</td>
<td>—</td>
<td>—</td>
<td style="text-align:right">—</td>
<td>—</td>
</tr>
</tbody>
</table>
<h3 id="risk-assessment">Risk assessment</h3>
<ul>
<li>Groq may fail as a LLM provider and we are unable to find affordable and functional alternatives
<ul>
<li>Low liklihood of occuring</li>
<li>High impact if it occurs</li>
<li>The liklihood of it occuring is low because Groq is known for being reliable due to its
performance-focused approach The impact is high because if the Groq fails as an LLM provider,
it could lead to loss of functionality in the website. We as the team would need to refactor
large portions of code and lead to not finishing the project on time.</li>
<li>Steps you are taking to reduce the likelihood or impact, and steps to permit better estimates;</li>
<li>To reduce the likihood or impact, the team will arefully read API docs to not use any depricated features</li>
<li>To detect if Groq has failed on us, we will look for any thrown API error responses</li>
<li>Should this occur, we would look into what error is being thrown, find where the issue is and debug. We will
design our product to be highly modular with regard to both the LLM API provider and  the LLM model itself.
This will allow us to be able to easily switch both models and providers if ever deemed necessary.</li>
</ul>
</li>
<li>Team members may not be able to find enough time for development and the project may fail to stay on schedule.
<ul>
<li>Medium liklihood of occuring</li>
<li>Meduim impact if it occurs</li>
<li>It can be hard to estimate how long a task will take us, especially since we are students and are still learning the pacing
of larger projects. It is not rare for a team to find they don't have as much time as they hoped, so although it could be hard,
there are many different tatics we can use to overcome this.</li>
<li>Steps we are taking in order to avoid this from happening are, looking over the schedule, asking the team where they are at and
what they are currently working on so everyone is able to be on track.</li>
<li>To detect the problem, we look back at our planned out schedule, making sure we are all on track</li>
<li>To mitigate this, there will be a constant monitoring of progress to ensure that either the team stays on schedule,
or the correct steps are made to either adjust the schedule, expectations for the project, or to increase the productivity of
the team. Additionally, roles in the team will shift in order to help whichever side of the project needs more help.</li>
</ul>
</li>
<li>Interactive tree or nodes more complex than expected and blocks core features, causing delays to the release.
<ul>
<li>Low liklihood</li>
<li>Low impact to occur</li>
<li>Since we are planning to start out really simple and work our way up to a more complex trees/nodes, we plan to solidify before
adding a layer of complexities, so the liklihood should be low. If it was to happen, we would backtrack to our latest design that
worked</li>
<li>As previously said, in order to avoid complications with complex tree and node features, we plan to begin with simple implementations,
adding layers of complexity once the prevoius layer is solid. We check that a &quot;layer of complexity&quot; is solid with testing.</li>
<li>To detect this problem we will interact with the website ourselves and use tests to find any issues</li>
<li>To mitigate this, we will have the frontend working on a UI/UX skeleton of the nodes for the trees that later can be
populated with LLM generated information. We will ensure that the frontend and backend on on the same page regarding the data structure of the trees and nodes, so that the frontend is ready for the API response of the backend.</li>
</ul>
</li>
<li>May focus too much on the stretch goals, before solidifying the necessary features for the site.
<ul>
<li>Low liklihood</li>
<li>Meduim impact</li>
<li>At the very beginning of our project planning we chose what our strech goals are, and as long as people stick to the plan, the liklihood
it happening are very low. If we do begin to focus to much on the strech goals, we may lose time that should have been used for the
must haves of the project, setting us back.</li>
<li>The steps to avoid this problem are, we plan to communicate what we are working on, double checking that it aligns with the schedule.</li>
<li>We would detect this issue by looking at how much we have completed for the project, and deciding as a team which stretch goals would
serve us best for whatever time we may have left before the deadline</li>
<li>To mitigate this, we plan to continue to remind each other of what are the needs and wants of the project and what should be completed
for that week</li>
</ul>
</li>
<li>Overuse or spikes in traffic could exceed limits, causing service interuptions
<ul>
<li>Medium liklihood</li>
<li>High impact</li>
<li>The likihood of it happening are meduim because rate limits are common during testing and
scaling phases. The impact is high because if it is triggered, the functionality of the
website relying on the LLM could slow or completely stop.</li>
<li>To reduce the likilihood or impact, we could add caching for repeated queries to lessen API
calls</li>
<li>To detect the problem we would monitor the API status code error indicating too many requests
in a short period.</li>
</ul>
</li>
</ul>
<h3 id="test-plan--bugs">Test plan &amp; bugs</h3>
<h4 id="unit-tests">Unit Tests</h4>
<p>Unit tests will verify that the smallest functional parts of the system behave as expected. Since our backend follows a REST architecture, we will write Jest tests for each REST endpoint covering typical, boundary, and failure cases. This includes:</p>
<ul>
<li>User routes: authentication, sessions, and access control.</li>
<li>Tree routes: creation, retrieval, and updates of user trees.</li>
<li>Node routes: generation of nodes, retrieval of nodes</li>
<li>Flashcard routes: generation of flashcards, retrieval of nodes, and spaced-repetition scheduling logic.</li>
</ul>
<p>Mock data will be used for database calls (via Prisma mock client) and for LLM responses, so that tests remain fast and deterministic. Each test will check both the returned JSON structure and the database side effects, ensuring schema alignment. We consider our unit test suite sufficient when it covers all REST endpoints and their common error cases.</p>
<p>Adding a test is done by creating a file ending in '.test.ts' in the test folder. Tests must be written so that they follow Jest documentation, and more information about how to implement tests can be found in the developer documentation at the bottom of this document.</p>
<p>We found Jest to be a suitable test framework due to its typescript oriented design and high compatability with Next.js. Mocha could have been a good alternative, but lacked sufficient support for the type of modules this project uses. Due to team members' prior experience with Mocha, and Mocha's similarity to Jest both in style and implementation, it was determined</p>
<h4 id="test-automation">Test Automation</h4>
<p>We are using gitHub</p>
<h4 id="usability-testing">Usability Testing</h4>
<p>Usability testing will take place once the main user flows are implemented. Our approach will be “hallway testing”: informal but structured sessions where participants use GPTree with minimal explanation while we observe where confusion or friction occurs.
Each round of usability testing will have specific goals (e.g., “Can users find how to generate a follow-up node?” or “Do users understand how to review flashcards?”). Results will be summarized and prioritized into GitHub Issues, guiding the next design or UX iteration.</p>
<h4 id="bug-tracking">Bug Tracking</h4>
<p>All bugs and feature regressions will be tracked using GitHub Issues. Each issue will include:</p>
<ul>
<li>
<p>Clear description of the problem and steps to reproduce</p>
</li>
<li>
<p>Screenshots or stack traces where applicable</p>
</li>
<li>
<p>Labels indicating severity, area (frontend/backend/UI), and milestone</p>
</li>
<li>
<p>Assignment to responsible team members</p>
</li>
</ul>
<p>Issues discovered through testing will be linked to specific commits or pull requests for traceability. Resolved issues will be verified in the next test cycle before closing.</p>
<h3 id="documentation-plan">Documentation plan</h3>
<ul>
<li>We will document every software component and API endpoints in our Software Design section of this document
<ul>
<li>This will include making sure to note how components relate to each other. And documenting our React Component Hierarchy.</li>
<li>There will be documentation for each REST endpoint in a .md file in git. In this file we plan to cover API request parameters, and expected response.</li>
</ul>
</li>
<li>For users documentation, we will have a help/FAQ page if they are to get stuck at any point while using the site
<ul>
<li>In support of this, we plan to implement either a &quot;learn more&quot; hyperlink or question mark button that will link the user to relevant guide pages if they need further explanation of using tools. Although we also plan on ensuring that GPTree is as intuitive as possible for users.</li>
</ul>
</li>
</ul>
<h3 id="getting-external-feedback">Getting External feedback</h3>
<p>External feedback will be the most useful the moment we have a functional backend/frontend. Once it is possible to generate a tree at all, it will be important to get user feedback for structural elements as well as potential ideas for features. As features are tweaked and added, we will want even more feedback. We will get this feedback by consulting friends, acquaintances, and random people in hallways. Ideally they can try out the feature with minimal context, so that we can assess the usability of the product.</p>
<h2 id="7-software-architecture"><strong>7. Software Architecture</strong></h2>
<p><img src="./devDiagrams/arch diagram.webp" alt="Architecture Diagram"></p>
<h3 id="71-overview-of-system-architecture">7.1 Overview of System Architecture</h3>
<p>The components of our app that power the backend provide two main functionalities: first, we have a database, Prisma, that will allow us to store all of the ‘things’ that a user will be able to access through GPTree, and second, Groq, the LLM that will actually allow us to generate responses to the questions a user asks. For the frontend, we have a React app that will allow the client to see their trees and interact with our program. We are also using <strong>NextAuth.js</strong> to manage user authentication through both <strong>Google sign-in</strong> and <strong>magic link</strong> login methods.</p>
<p>To provide an interface between our frontend app and the tools in our backend (Prisma, Groq), we have an API layer that will allow the frontend code to ‘talk’ to the backend. We don’t want the client side code to directly interact with our database (which is already impossible with Prisma) or Groq for security reasons, control reasons, authorization reasons, etc. so we have ‘REST endpoints’ that our frontend will call. We can
use the standard HTTP/HTTPS ‘fetchʼ to access these endpoints, which will then use server side code to call the appropriate tool’s API. Our frontend will receive JSON responses from these calls, and then parse them appropriately.</p>
<p>We plan to <strong>deploy GPTree on Vercel</strong>, which provides built-in support for Next.js serverless functions and easy integration with Prisma. This allows for efficient deployment, continuous integration, and scaling with minimal configuration.</p>
<h3 id="72-detailed-view-of-system-architecture">7.2 Detailed View of System Architecture</h3>
<p>First, we will specify the way our fronend and backend communicate. We can call our endpoints with <code>fetch</code>, which allows us to provide information through the url or through the request body. When dealing with a request body, we use the NextRequest object's .json() method to convert the request into JSON, and the ZodObject .parse() method to convert this JSON into the appropriate record, which gives us the ability to catch an error if the request is not properly formatted. In general, we have our own schemas defined for every inetraction our frontend and backend have (for example, the schema that the frontend must satisfy to create a new user, plus the schema of what it will get back), and all of these are handled with Zod. Note that the validation_schemas.ts file contains any and all schemas we send/recieve or otherwise need to parse.</p>
<p>We will move from the 'farthest' parts of the backend (I.E. Prisma and Groq) to the 'closest' (I.E. the app that the client interacts with).</p>
<ul>
<li>Prisma
<ul>
<li>Includes its own methods for us to call in our backend: <code>create()</code>, <code>findMany()</code>, <code>deleteMany()</code>, etc.</li>
<li>After parsing a request to ensure it contains the information prisma requires to add/delete/alter entries in tables (e.g. CreateUserSchema in validation_schemas.ts), the route will call the appropriate prisma method, and then handle the returned information as needed</li>
<li>Depending on the operation, the backend route will send a different JSON object back to the client, for example, when a user is created, this JSON contains a record matching the <code>User</code> type in validation_schemas.t</li>
</ul>
</li>
<li>Groq
<ul>
<li>Includes its own methods for us to call in our backend: <code>create()</code>, <code>createInterface()</code>, etc.</li>
<li>Just like with Prisma, the backend will parse a request via Zod, then call the appropriate method from the Groq API</li>
<li>Groq, however, will also access our database in order to get access to the text associated with nodes that give the LLM the context it needs to generate good responses, and this will occur with the same prisma methods that the other routes use</li>
<li>Once the route gets what it needs from Groq, it will complete any remaining operations and return a JSON object to the client containing the response and any other data we choose to include</li>
</ul>
</li>
<li>API Layer
<ul>
<li>Consists of a file structure that Next.js uses for handling route navigation/resolution, where 'route.ts' files exist at all endpoints that our backend provides</li>
<li>The client can request, alter, or upload information to our database via <code>GET</code> and <code>POST</code> methods implemented in these files</li>
<li>Routes generally accept a NextRequest object, and somtimes other paramters, and return a JSON object via NextResponse.json() to the client</li>
<li>Routes in the backend are the only area where we actually reach out to our external tool API's (Prisma and Groq)</li>
</ul>
</li>
<li>Frontend
<ul>
<li>Navigation between different frontend pages occurs via the Next.js router, and backend interaction occurs via <code>fetch</code> methods.</li>
<li>The frontend will handle any and all HTML for the webpage, but will utilize the JSON it recieves from the backend</li>
<li>When calling backend endpoints, the frontend will use the information stored in its own state to provide the information these routes require, and if it isn't able to, it will change its behavior (i.e. the HTML it's displaying) depending on the status codes it recieves from the server</li>
</ul>
</li>
</ul>
<h3 id="73-data-storage-and-schema">7.3 Data Storage and Schema</h3>
<p>In general, there are four ‘things’ we need to store: <strong>User information</strong>, <strong>Trees</strong>, <strong>Nodes</strong>, and <strong>Flashcards</strong>. Prisma gives us a convenient abstraction about our relational database, as we can store actual objects and collections of objects inside of it. Prisma handles the conversion of this object abstraction into a form that actually matches the RDB abstraction, so we just have to think about objects. Our top-level schema is represented below in simplified database tables.</p>
<p>The first four models — User, Account, Session, and VerificationToken — are required by NextAuth.js to manage authentication and user sessions. They securely store user identities, linked login providers, active sessions, and verification tokens, forming the foundation that all GPTree data depends on.</p>
<hr>
<h4 id="user"><strong>User</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td><strong>PK</strong></td>
<td>Unique identifier for each user (auto-generated cuid).</td>
</tr>
<tr>
<td>name</td>
<td>String?</td>
<td>—</td>
<td>Full name of the user (optional).</td>
</tr>
<tr>
<td>email</td>
<td>String?</td>
<td><strong>UQ</strong></td>
<td>User's email address (used for login).</td>
</tr>
<tr>
<td>emailVerified</td>
<td>DateTime?</td>
<td>—</td>
<td>Timestamp of email verification.</td>
</tr>
<tr>
<td>createdAt</td>
<td>DateTime</td>
<td>—</td>
<td>When the user account was created.</td>
</tr>
<tr>
<td>image</td>
<td>String?</td>
<td>—</td>
<td>Profile picture URL.</td>
</tr>
<tr>
<td>accounts</td>
<td>Account[]</td>
<td>—</td>
<td>All authentication provider accounts linked to this user.</td>
</tr>
<tr>
<td>sessions</td>
<td>Session[]</td>
<td>—</td>
<td>All active sessions for this user.</td>
</tr>
<tr>
<td>trees</td>
<td>Tree[]</td>
<td>—</td>
<td>All trees created by this user.</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="account"><strong>Account</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td><strong>PK</strong></td>
<td>Unique identifier for each account record.</td>
</tr>
<tr>
<td>userId</td>
<td>String</td>
<td><strong>FK → User(id)</strong></td>
<td>References the user who owns this account.</td>
</tr>
<tr>
<td>type</td>
<td>String</td>
<td>—</td>
<td>Type of authentication (e.g., &quot;oauth&quot;, &quot;email&quot;).</td>
</tr>
<tr>
<td>provider</td>
<td>String</td>
<td>—</td>
<td>Name of the authentication provider (e.g., &quot;google&quot;, &quot;auth0&quot;).</td>
</tr>
<tr>
<td>providerAccountId</td>
<td>String</td>
<td><strong>UQ (per provider)</strong></td>
<td>Unique account ID assigned by the provider.</td>
</tr>
<tr>
<td>refresh_token</td>
<td>String?</td>
<td>—</td>
<td>OAuth refresh token, if provided.</td>
</tr>
<tr>
<td>access_token</td>
<td>String?</td>
<td>—</td>
<td>OAuth access token.</td>
</tr>
<tr>
<td>expires_at</td>
<td>Int?</td>
<td>—</td>
<td>Expiration timestamp for the token.</td>
</tr>
<tr>
<td>token_type</td>
<td>String?</td>
<td>—</td>
<td>Type of access token (e.g., &quot;Bearer&quot;).</td>
</tr>
<tr>
<td>scope</td>
<td>String?</td>
<td>—</td>
<td>OAuth scopes granted by the provider.</td>
</tr>
<tr>
<td>id_token</td>
<td>String?</td>
<td>—</td>
<td>ID token returned by the provider.</td>
</tr>
<tr>
<td>session_state</td>
<td>String?</td>
<td>—</td>
<td>Additional session state data.</td>
</tr>
<tr>
<td>user</td>
<td>User</td>
<td>—</td>
<td>Relation to <strong>User</strong> (many-to-one).</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="session"><strong>Session</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td><strong>PK</strong></td>
<td>Unique identifier for the session record.</td>
</tr>
<tr>
<td>sessionToken</td>
<td>String</td>
<td><strong>UQ</strong></td>
<td>Token identifying the user session.</td>
</tr>
<tr>
<td>userId</td>
<td>String</td>
<td><strong>FK → User(id)</strong></td>
<td>Links the session to its associated user.</td>
</tr>
<tr>
<td>expires</td>
<td>DateTime</td>
<td>—</td>
<td>Timestamp of session expiration.</td>
</tr>
<tr>
<td>user</td>
<td>User</td>
<td>—</td>
<td>Relation to <strong>User</strong> (many-to-one).</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="verificationtoken"><strong>VerificationToken</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>identifier</td>
<td>String</td>
<td>—</td>
<td>The email or identifier of the user.</td>
</tr>
<tr>
<td>token</td>
<td>String</td>
<td><strong>UQ</strong></td>
<td>Token used for magic link or email verification.</td>
</tr>
<tr>
<td>expires</td>
<td>DateTime</td>
<td>—</td>
<td>Timestamp when this token becomes invalid.</td>
</tr>
<tr>
<td><em>(no relations)</em></td>
<td>—</td>
<td>—</td>
<td>Standalone table used for login verification.</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="tree"><strong>Tree</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>Int</td>
<td><strong>PK</strong></td>
<td>Unique identifier for each learning tree.</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>—</td>
<td>Name or title of the tree.</td>
</tr>
<tr>
<td>userId</td>
<td>String</td>
<td><strong>FK → User(id)</strong></td>
<td>References the user who owns the tree.</td>
</tr>
<tr>
<td>createdAt</td>
<td>DateTime</td>
<td>—</td>
<td>When the tree was created.</td>
</tr>
<tr>
<td>updatedAt</td>
<td>DateTime</td>
<td>—</td>
<td>Automatically updates whenever the tree changes.</td>
</tr>
<tr>
<td>user</td>
<td>User</td>
<td>—</td>
<td>Relation to <strong>User</strong> (many-to-one).</td>
</tr>
<tr>
<td>node</td>
<td>Node[]</td>
<td>—</td>
<td>Relation to <strong>Node</strong> (one-to-many).</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="node"><strong>Node</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>Int</td>
<td><strong>PK</strong></td>
<td>Unique identifier for each node.</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>—</td>
<td>Short name or title for the node.</td>
</tr>
<tr>
<td>question</td>
<td>String</td>
<td>—</td>
<td>The question or topic that the node represents.</td>
</tr>
<tr>
<td>content</td>
<td>String</td>
<td>—</td>
<td>The generated explanation or main content of the node.</td>
</tr>
<tr>
<td>followups</td>
<td>String[]</td>
<td>—</td>
<td>List of suggested follow-up questions.</td>
</tr>
<tr>
<td>treeId</td>
<td>Int</td>
<td><strong>FK → Tree(id)</strong></td>
<td>Links the node to its parent tree.</td>
</tr>
<tr>
<td>tree</td>
<td>Tree</td>
<td>—</td>
<td>Relation to <strong>Tree</strong> (many-to-one).</td>
</tr>
<tr>
<td>parentId</td>
<td>Int?</td>
<td><strong>FK → Node(id)</strong></td>
<td>Optional reference to the parent node (if this node is a child).</td>
</tr>
<tr>
<td>parent</td>
<td>Node?</td>
<td>—</td>
<td>Relation to the parent <strong>Node</strong> (many-to-one).</td>
</tr>
<tr>
<td>children</td>
<td>Node[]</td>
<td>—</td>
<td>Relation to all child <strong>Nodes</strong> (one-to-many self-relation).</td>
</tr>
<tr>
<td>flashcards</td>
<td>Flashcard[]</td>
<td>—</td>
<td>Relation to <strong>Flashcard</strong> (one-to-many).</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="flashcard"><strong>Flashcard</strong></h4>
<table>
<thead>
<tr>
<th><strong>Field Name</strong></th>
<th><strong>Type</strong></th>
<th><strong>Key</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>Int</td>
<td><strong>PK</strong></td>
<td>Unique identifier for each flashcard.</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>—</td>
<td>Title or keyword label for the flashcard.</td>
</tr>
<tr>
<td>content</td>
<td>String</td>
<td>—</td>
<td>The question-and-answer text content of the flashcard.</td>
</tr>
<tr>
<td>nodeId</td>
<td>Int</td>
<td><strong>FK → Node(id)</strong></td>
<td>References the node that this flashcard belongs to.</td>
</tr>
<tr>
<td>node</td>
<td>Node</td>
<td>—</td>
<td>Relation to <strong>Node</strong> (many-to-one).</td>
</tr>
</tbody>
</table>
<h3 id="74-assumptions">7.4 Assumptions</h3>
<p>One large assumption we’re making is that the responses we get from Groq will be generally acceptable to the user. There’s a limit to what we can do to prevent or handle hallucinations, especially with more complex topics that we might not account for during development. While this is a risk we would have to mitigate with any LLM, it’s a general assumption that the majority of what the user gets back will be of good quality. If, for whatever reason, the LLM we have spits out incorrect, misleading, or confusing information, it would compromise the quality of GPTree, meaning we need to be especially cautious when working with the LLM component of our system (as in choosing what context we give it, how user questions convert to prompts, etc.).</p>
<h3 id="75-decisions-and-alternatives">7.5 Decisions and Alternatives</h3>
<p>One of the core architectural decisions for GPTree was to adopt a Model–View–Controller (MVC) structure within our web framework. This style organizes the system into three main components: the Model, represented by our Prisma schema and database logic; the View, consisting of React and Next.js pages that render Trees, Nodes, and Flashcards; and the Controller, which corresponds to our API routes that coordinate between user actions and backend logic. An alternative to this decision would be used a simple client-server architecture model. The pros of this alternative is mainly the simplicity of the architecture, and may allow us to change certain details on the fly as needed. But in general the cons of a poorly defined architecture without much detail overrides the pros, and for this reason we use the MVC architecture.</p>
<p>An additional architectural decision that we made we was to not have any asynchronus pipelines, which was considered to support our spaced repetition learning feature. This would have followed a queue-based model, where flashcard updates and scheduling calculations occur independently of user actions. While that approach could scale well for a large user base and offload work from the client, it would also introduce additional system complexity—requiring persistent job queues, worker processes, and more coordination between services. Instead, we chose instead to favor simplicity and find ways to calculate which items should be in the feed during a single GET request based on time-stamp data and pre-generated flash cards.</p>
<p>Another decision was to use Prisma instead of another ORM (object relational mapper, I.E. the abstraction between a normal RDB and one with objects) such as Drizzle. Our choice to use Next.js as our framework is crucial in choosing an ORM, as different options have different levels of compatibility with our chosen framework. In this case, Prisma has Next.js guides in its official documentation, and very deep integration with Next.js, meaning that, not only is using Prisma in our project easier, but troubleshooting will also be easier because of the larger amount of tutorials, guides, and support that other developers have created. Drizzle does offer its own advantages though, most notably, its similarity to traditional SQL. Writing a query in Drizzle is slightly more explicit than in Prisma, and as a result, slightly more intuitive. This means that we could spend less time trying to learn new methods and query techniques, and rely on prior knowledge about SQL. Considering the time we’ve ‘saved’ by choosing Next.js, however, it’s reasonable to allocate some extra time to familiarize ourselves with Prisma, as its integration with Next.js will most likely make our lives much easier when working with our database farther down the line.</p>
<h2 id="8-software-design"><strong>8. Software Design:</strong></h2>
<h3 id="81-frontend--react-nextjs">8.1 Frontend — React (Next.js)</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Display learning trees, nodes, and flashcards.</li>
<li>Handle interactions (follow-ups, generate flashcards, study).</li>
<li>Call backend REST endpoints and manage basic client state.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li>Built with <strong>Next.js</strong> (routing/SSR) and <strong>React</strong> components.</li>
<li>Organized into pages (Tree view, Study) and reusable components (Node, Flashcard).</li>
<li>Uses fetch over HTTPS for API calls.</li>
<li>Deployed on <strong>Vercel</strong> alongside the backend.</li>
</ul>
<hr>
<h3 id="82-authentication--nextauthjs">8.2 Authentication — NextAuth.js</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Authentication and session management.</li>
<li>Google sign-in and magic link email login.</li>
<li>Provide secure user identity to frontend and backend.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li>Implemented with <strong>NextAuth.js</strong> as an API route.</li>
<li>Cookie-based sessions accessible server-side and client-side.</li>
</ul>
<hr>
<h3 id="83-api-layer--rest-endpoints">8.3 API Layer — REST Endpoints</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Interface between frontend and backend services.</li>
<li>Expose endpoints for Trees, Nodes, Flashcards, and Study (SRS).</li>
<li>Enforce authentication and authorization.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li><strong>Next.js API routes</strong> returning and accepting JSON.</li>
<li>Internally calls <strong>Prisma</strong> (database) and <strong>Groq</strong> (LLM) as needed.</li>
</ul>
<hr>
<h3 id="84-database--prisma-postgresql">8.4 Database — Prisma (PostgreSQL)</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Persist Users, Trees, Nodes, and Flashcards.</li>
<li>Maintain data integrity and relationships (e.g., Node belongs to Tree).</li>
<li>Support create, read, and update operations for learning structures.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li><strong>Prisma ORM</strong> over <strong>PostgreSQL</strong>.</li>
<li>Models defined in a Prisma schema generate a type-safe client used in API routes.</li>
<li>All database access is server-side only.</li>
</ul>
<hr>
<h3 id="85-llm-integration--groq-api">8.5 LLM Integration — Groq API</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Generate node content and flashcards from user prompts.</li>
<li>Provide suggested follow-up questions and structured learning output.</li>
<li>Act as the content generation layer.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li>Backend calls the <strong>Groq API</strong> from routes or services.</li>
<li>Prompts include the user’s question and context; outputs are parsed and validated server-side.</li>
<li>Timeouts and errors are handled gracefully for a stable UI.</li>
</ul>
<hr>
<h3 id="86-deployment--vercel">8.6 Deployment — Vercel</h3>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Host the frontend and serverless API.</li>
<li>Provide continuous deployment and scaling.</li>
<li>Manage environment configuration.</li>
</ul>
<p><strong>Formation:</strong></p>
<ul>
<li><strong>Vercel</strong> deploys the Next.js app; API routes run as serverless functions.</li>
<li><strong>Prisma</strong> connects to the hosted PostgreSQL database at runtime.</li>
<li>Preview deployments are used for feature branches.</li>
</ul>
<h2 id="developer-documentation"><strong>Developer Documentation</strong></h2>
<p>Clone <code>git@github.com:Britwad/GPTree.git</code> or <code>https://github.com/Britwad/GPTree.git</code> and change into the project directory. Run <code>npm install</code> to fetch dependencies. Copy <code>.env.example</code> to <code>.env</code> and fill the values for Google auth, the database URL, and the Groq key. You can use a local PostgreSQL instance or start one with Docker compose. There are no submodules.</p>
<p>The <code>app</code> folder holds the Next.js application and the API route handlers under <code>app/api</code>. The <code>components</code> folder contains reusable React components. The <code>lib</code> folder contains helpers such as the Prisma client and auth utilities. The <code>prisma</code> folder contains the Prisma schema, migrations, and the seed script. The <code>test</code> folder contains Jest tests. The <code>types</code> folder holds shared TypeScript types. The <code>public</code> folder serves static assets. Repository documents such as the living document and coding guidelines live at the root along with configuration files like <code>jest.config.js</code>, <code>next.config.ts</code>, and <code>tsconfig.json</code>.</p>
<p>Ensure a PostgreSQL database is reachable and that <code>DATABASE_URL</code> is set in <code>.env</code>. Generate the Prisma client with <code>npx prisma generate</code> and apply migrations with <code>npx prisma migrate dev</code> for development or <code>npx prisma migrate deploy</code> for production. Build the application with <code>npm run build</code> and start it with <code>npm start</code>. During development you can run <code>npm run dev</code> to launch the local server at <code>http://localhost:3000</code>.</p>
<p>Run <code>npm test</code> to execute the Jest test suite. No extra setup is required after <code>npm install</code>. Tests run against the application code and use mocks for external services. If you need integration tests with a database, point <code>DATABASE_URL</code> to a dedicated test database. Use <code>npm run test:watch</code> for watch mode and <code>npm run test:cov</code> for coverage when those scripts are present in <code>package.json</code>.</p>
<p>Add tests in the <code>test</code> folder and name each file after what it covers with a <code>.test.ts</code> suffix, for example <code>user_routes.test.ts</code>. Group related tests with a <code>describe</code> block whose string clearly names the subject, such as <code>testing tree route</code> or <code>tree routes</code>. Each behavior should be checked in a separate <code>it</code> block that reads like a sentence, for example <code>adds a tree to the database</code>. Use <code>beforeAll</code>, <code>afterAll</code>, and <code>beforeEach</code> for setup and cleanup, such as resetting or seeding the database. Assertions use Jest’s <code>expect</code> API to compare actual results with expected results. Keep tests deterministic by mocking external services like the LLM adapter and any network requests. For route tests, Supertest can be used once a lightweight test server helper is added to the repo.</p>
<p>We are a webapp and the analogous release artifact is a Vercel production deployment of the Next.js build.</p>

</body>
</html>
